import { existsSync, mkdirSync, writeFileSync } from 'node:fs'
import { join as pathJoin, dirname } from 'node:path'
import { createRequire } from 'node:module'

// Source: https://stackoverflow.com/questions/10111163/how-can-i-get-the-path-of-a-module-i-have-loaded-via-require-that-is-not-mine
const getModuleDir = (moduleEntry) => {
  const packageName = moduleEntry.includes('/')
    ? moduleEntry.startsWith('@')
      ? moduleEntry.split('/').slice(0, 2).join('/')
      : moduleEntry.split('/')[0]
    : moduleEntry
  const require = createRequire(import.meta.url)
  const lookupPaths = require.resolve
    .paths(moduleEntry)
    .map((p) => pathJoin(p, packageName))
  return lookupPaths.find((p) => existsSync(p))
}

const stylePath = getModuleDir('@design-system/style')
const corePath = getModuleDir('@design-system/core')

const saveFile = (path, data) => {
  const dir = dirname(path)
  if (!existsSync(dir)) {
    mkdirSync(dir)
  }
  writeFileSync(path, data)
}

const preprocessPEWC = (options = {}) => {
  options.statsPath ??= './build/_pewc.json'
  options.css ??= {}
  if (options.css) {
    options.css.path ??= './build/_app.css'
    options.css.theme ??= `@design-system/style/theme.css`
  }
  //options.css.classes ??= []
  options.pewc ??= {}
  if (options.pewc) {
    options.pewc.path ??= './build/_bootstrap.js'
    options.pewc.bootstrap ??= ['webcomponents']
  }

  const tags = {}
  const classes = {}
  const pewc = {}

  // TODO make single RegExp
  const tagRegExp = /<([a-z]+)[ >]/g
  const classRegExp = /<([a-z]+) .*class="?([a-z- ]+)"?[ >]/g
  const pewcRegExp = / is="?([a-z]+-[a-z]+)"?[ >]/g
  const markup = ({ content, filename }) => {
    if (process.env.NODE_ENV === 'production') {
      let match
      while ((match = tagRegExp.exec(content))) {
        tags[match[1]] ??= 0
        tags[match[1]] += 1
      }
      while ((match = classRegExp.exec(content))) {
        const tag = match[1]
        const classList = match[2].split(' ')
        for (const className of classList) {
          let key = `.${className}`
          classes[key] ??= 0
          classes[key] += 1
          key = `${tag}.${className}`
          classes[key] ??= 0
          classes[key] += 1
        }
      }
      while ((match = pewcRegExp.exec(content))) {
        pewc[match[1]] ??= 0
        pewc[match[1]] += 1
      }
    }

    return { code: content }
  }

  if (process.env.NODE_ENV === 'production') {
    const exitHandler = () => {
      if (options.statsPath) {
        saveFile(
          options.statsPath,
          JSON.stringify({ tags, classes, pewc }, null, 2)
        )
      }

      if (options.css !== false) {
        let list = Object.keys(tags)
        list.sort()
        let css = `/* generated by @design-system/svelte-preprocess-pewc */\n`
        css += `@import '@design-system/style/base.css';\n`
        css += `@import '@design-system/style/media.css';\n`
        for (const key of list) {
          if (existsSync(`${stylePath}/element/${key}.css`)) {
            css += `@import '@design-system/style/element/${key}.css';\n`
          }
        }
        list = Object.keys(classes)
        list.sort()
        for (const key of list) {
          if (existsSync(`${stylePath}/element/${key}.css`)) {
            css += `@import '@design-system/style/classes/${key}.css';\n`
          }
        }
        css += `@import '${options.css.theme}';\n`
        saveFile(options.css.path, css)
      }
      if (options.pewc !== false) {
        const list = Object.keys(options.pewc.bootstrap)
        list.sort()
        let bootstrap = `/* generated by @design-system/svelte-preprocess-pewc */\n`
        for (const key of list) {
          if (existsSync(`${corePath}/${key}.js`)) {
            bootstrap += `import '@design-system/core/${key}.js'\n`
          }
        }
        saveFile(options.pewc.path, bootstrap)
      }
      process.exit()
    }
    process.on('exit', exitHandler)
    process.on('SIGINT', exitHandler)
    process.on('uncaughtException', exitHandler)
  }
  return { markup }
}

export default preprocessPEWC
